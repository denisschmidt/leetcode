// Binary Tree Traversal

// Задачи на leetcode #94 #144 #145

// Cуществуют разные способы посещения всех узлов или поиска значения в двоичном дереве.

// In Order Traversal

// ВАЖНО!!!! Только если у нас только BST дерево то мы можем использовать подобный обход для получения значений в порядке возрастания

// Посещаем узлы в порядке left-root-right

// Визуализация обхода In Order
// https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solution/

/*
         10
       /    \
      5      30
    /       /  \
   4       15   40
 /
3

[3, 4, 5, 10, 15, 30, 40]


 */

// Time O(N) - где N - количество узлов в дереве. Мы перебираем каждый узел один раз.
// Space O(H) - где H - высота дерева. Это пространство, стеком вызовов при вызове dfs.
const inorderTraversal = root => {
  let stack = [];
  let node = root;
  let ans = [];

  while (stack.length || node !== null) {
    while (node !== null) {
      stack.push(node);
      node = node.left;
    }

    node = stack.pop();
    ans.push(node.val);
    node = node.right;
  }

  return ans;
};

const inorderTraversal2 = root => {
  const nums = [];

  dfs(root);

  return nums;

  function dfs(node) {
    if (node === null) return;

    inorderTraversal2(node.left);

    nums.push(node.val);

    inorderTraversal2(node.right);
  }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Pre Order Traversal

// Посещаем узлы в порядке root-left-right

/*

         10
       /    \
      5      30
    /       /  \
   4       15   40
 /
3

[10, 5, 4, 3, 30, 15, 40]

 */

// Time O(N)
// Space O(N)
const preorderTraversal = root => {
  const stack = [];
  const ans = [];
  stack.push(root);

  while (stack.length) {
    let node = stack.pop();

    if (node !== null) {
      ans.push(node.val);
      stack.push(node.right);
      stack.push(node.left);
    }
  }

  return ans;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Post-order Traversal

// Посещаем узлы в порядке left-right-root

/*

         10
       /    \
      5      30
    /       /  \
   4       15   40
 /
3

[3, 4, 5, 15, 40, 30, 10]

 */

// Time O(N)
// Space O(N)
const postorderTraversal = root => {
  if (root === null) return [];

  const stack = [];
  const ans = [];
  stack.push(root);

  while (stack.length) {
    let node = stack.pop();

    ans.unshift(node.val);

    if (node.left !== null) stack.push(node.left);

    if (node.right !== null) stack.push(node.right);
  }

  return ans;
};
