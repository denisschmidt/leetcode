// Binary Tree Traversal

// Cуществуют разные способы посещения всех узлов или поиска значения в двоичном дереве.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// In Order Traversal

// Если у нас BST дерево то мы можем использовать подобный обход для получения значений в порядке возрастания

// Посещаем узлы в порядке left-root-right

/*
         10
       /    \
      5      30
    /       /  \
   4       15   40
 /
3

[3, 4, 5, 10, 15, 30, 40]


 */

// Time O(N)
// Space O(N)
const inorderTraversal = root => {
  let stack = [];
  let node = root;
  let ans = [];

  while (stack.length || node !== null) {
    while (node !== null) {
      stack.push(node);
      node = node.left;
    }

    node = stack.pop();
    ans.push(node.val);
    node = node.right;
  }

  return ans;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Pre Order Traversal

// Посещаем узлы в порядке root-left-right

/*

         10
       /    \
      5      30
    /       /  \
   4       15   40
 /
3

[10, 5, 4, 3, 30, 15, 40]

 */

// Time O(N)
// Space O(N)
const preorderTraversal = root => {
  const stack = [];
  const ans = [];
  stack.push(root);

  while (stack.length) {
    let node = stack.pop();

    if (node !== null) {
      ans.push(node.val);
      stack.push(node.right);
      stack.push(node.left);
    }
  }

  return ans;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Post-order Traversal

// Посещаем узлы в порядке left-right-root

/*

         10
       /    \
      5      30
    /       /  \
   4       15   40
 /
3

[3, 4, 5, 15, 40, 30, 10]

 */

// Time O(N)
// Space O(N)
const postorderTraversal = root => {
  if (root === null) return [];

  const stack = [];
  const ans = [];
  stack.push(root);

  while (stack.length) {
    let node = stack.pop();

    ans.unshift(node.val);

    if (node.left !== null) stack.push(node.left);

    if (node.right !== null) stack.push(node.right);
  }

  return ans;
};
