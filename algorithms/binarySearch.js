/*
  Пространственно-временная сложность: 
  
  Time: O(log N) - логорифмическое время 
  Space: O(1)

  Почему O(log N)? 
  
  Двоичный поиск выполняется путем деления существующего массива пополам. 
  
  Таким образом, каждый раз, когда вы вызываете подпрограмму (или завершаете одну итерацию), размер уменьшается до половины существующей части. 
  
  Сначала N становится N / 2, затем становится N / 4 и продолжается до тех пор, пока не найдет элемент или размер, равный 1.
  
  Максимальное количество итераций - logN (база 2).


  3 шаблона Бинарного поиска !!!
  
  Каждый раз при решении задачи через бинарный поиск и анализе этого кода, кажется что реализация постоянно отличается. 
  
  Хотя каждая реализация делит проблемное пространство на 1/2 на каждом шаге, может появиться много вопросов: 
  
  Почему это было реализовано немного по-другому? 
  О чем думал разработчик? 
  Какой путь был проще? 
  Какой способ лучше? 
  
  Именно поэтому есть 3 основных шаблона для бинарного поиска.
  

  Шаблон № 1:
    Используется для поиска элемента или условия, которые могут быть определены путем доступа к одному индексу в массиве.


  Ключевые атрибуты:
    1) Основная и элементарная форма бинарного поиска
    2) Условие поиска можно определить, не сравнивая с соседями элемента (или использовать определенные элементы вокруг него) 
    3) Никакой постобработки не требуется, потому что на каждом шаге вы проверяете, был ли найден элемент. 
    4) Если вы дойдете до конца, то вы знаете, что элемент не найден


  Реализация итеративного и рекурсивного алгоритма приведены ниже.
*/

// A iterative binary search
function binarySearch_I(nums, target) {
  if (nums.length == 0) {
    return -1;
  }

  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    // так же середину можно найти вот так: let mid = (right + left) >>> 1;
    let mid = left + Math.floor((right - left) / 2);

    if (nums[mid] === target) {
      return mid;
    }

    if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// A recursive binary search function
function binarySearchReq_I(nums, target) {
  let index = find(0, nums.length - 1);

  return index;

  function find(lo, hi) {
    if (lo <= hi) {
      let mid = lo + Math.floor((hi - lo) / 2);

      if (nums[mid] === target) {
        return mid;
      }

      if (nums[mid] > target) {
        return find(lo, mid - 1);
      } else {
        return find(mid + 1, hi);
      }
    }

    return -1;
  }
}

/*

  Шаблон № 2: 
    Является расширенной формой бинарного поиска. 

    Он используется для поиска элемента или условия, которое требует доступа к текущему индексу
    и индексу его непосредственного правого соседа в массиве.

    Ключевые атрибуты: 
      1) Усовершенствованный способ реализации бинарного поиска.
      2) Условию поиска необходим доступ к непосредственному правому соседу элемента
      3) Используйте правого соседа nums[right], чтобы определить, выполнено ли условие и решить, идти ли налево или направо
      4) Поисковое пространство имеет размер не менее 2 на каждом шаге
      5) Требуется постобработка. Цикл / рекурсия заканчивается, когда у вас остался 1 элемент. 
         Необходимо оценить, соответствует ли оставшийся элемент условию. 

    Отличительный синтаксис: 
      Начальное условие: left = 0, right = nums.length 
      Выход из цикла: left == right 
      Поиск слева: right = mid 
      Поиск справа: left = mid + 1


  Реализация итеративного алгоритма приведена ниже.
*/

function binarySearch_II(nums, target) {
  if (nums.length == 0) {
    return -1;
  }

  let left = 0;
  let right = nums.length;

  while (left < right) {
    let mid = lo + Math.floor((hi - lo) / 2);

    if (nums[mid] == target) return mid;

    if (nums[mid] < target) {
      left = mid + 1;
    } else {
      // Правая сторона nums[right] стоит на месте
      // Чтобы определить, выполнено ли условие и решить, идти налево или направо
      right = mid;
    }
  }

  // Post-processing:
  // End Condition: left == right !!!!
  //
  if (left != nums.length && nums[left] == target) {
    return left;
  }

  return -1;
}

/*

  Шаблон № 3:

  Еще одна уникальная форма бинарного поиска. 
  Он используется для поиска элемента или условия которое требует доступа к текущему индексу
  и индексу его непосредственного левого и правого соседа в массиве.

  Ключевые атрибуты: 
    1) Альтернативный способ реализации бинарного поиска 
    2) Условию поиска необходимо получить доступ к ближайшим левым и правым соседям элемента
    3) Используйте соседей элемента, чтобы определить, выполнено ли условие, и решить, идти ли налево или направо 
    5) Поисковое пространство имеет размер не менее 3 на каждом шаге 
    6) Требуется постобработка. 
    7) Цикл / рекурсия заканчивается, когда у вас осталось 2 элемента. 
    8) Необходимо оценить, соответствуют ли остальные элементы условию.
*/

function binarySearch_III(nums, target) {
  if (nums.length == 0) return -1;

  let left = 0;
  let right = nums.length - 1;

  while (left + 1 < right) {
    let mid = lo + Math.floor((hi - lo) / 2);

    if (nums[mid] == target) {
      return mid;
    } else if (nums[mid] < target) {
      left = mid;
    } else {
      right = mid;
    }
  }

  // Post-processing:
  // End Condition: left + 1 == right !!!!
  if (nums[left] == target) return left;

  if (nums[right] == target) return right;

  return -1;
}
