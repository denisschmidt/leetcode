/*

  Алгоритм Краскала — эффективный алгоритм построения минимального остовного дерева(minimum spanning tree in graph) взвешенного связного неориентированного графа.

  Описание алгоритма:
    В начале текущее множество рёбер устанавливается пустым. 
    
    Затем, пока это возможно, проводится следующая операция: из всех рёбер, добавление которых к уже имеющемуся множеству не вызовет появление в нём цикла, выбирается ребро минимального веса и добавляется к уже имеющемуся множеству.
    
    Когда таких рёбер больше нет, алгоритм завершён. 
    
    Подграф данного графа, содержащий все его вершины и найденное множество рёбер, является его остовным деревом минимального веса. 
    
  Оценка сложности:

    До начала работы алгоритма необходимо отсортировать рёбра по весу, это требует O(E × log(E)) времени. 
    
    После чего компоненты связности удобно хранить в виде системы непересекающихся множеств. 
    
    Все операции в таком случае займут O(E × α(E, V)), где α — функция, обратная к функции Аккермана. 
    
    Поскольку для любых практических задач α(E, V) < 5, то можно принять её за константу
    
    Таким образом, общее время работы алгоритма Краскала можно принять за O(E * log(E) + E).

  Итого: 
    Как результат мы получаем сумму минимального остовного дерева взвешенного связного неориентированного графа.

*/

// Time O(ELogE + (V + E) * alpha(V)) where alpha(V) - обратная функция Аккермана
// Space O(E)
const kruskalMST = (n, prims) => {
  let parent = [];

  for (let i = 0; i <= n; i++) {
    parent[i] = i;
  }

  prims.sort((a, b) => a[2] - b[2]);

  let ans = 0;
  for (let [u, v, cnt] of prims) {
    // Если ребро не добавляет цикла
    if (union(u, v)) {
      ans += cnt;
    }
  }

  return ans;

  function union(x, y) {
    let xr = find(x);
    let yr = find(y);

    if (xr !== yr) {
      parent[yr] = xr;
      return true;
    }

    /*

      Что значит xr === yr ?
     
      Означает, что имеется пренадлежность к одному и тому же подмножеству. Тоесть компоненты уже являются связанным.
     
      Если связь уже есть, то считать сумму уже не нужно, так как меньшу сумму связи мы уже нашли.

      И так как мы отсортировали графы по стоимости, то если связи нету мы считаем сумму их связи.

    */

    return false;
  }

  function find(x) {
    if (x != parent[x]) {
      parent[x] = find(parent[x]);
    }
    return parent[x];
  }
};
