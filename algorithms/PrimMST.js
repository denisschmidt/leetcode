/*

  Алгоритм Прима — алгоритм построения минимального остовного дерева (minimum spanning tree in graph) взвешенного связного неориентированного графа.

  На вход алгоритма подаётся связный неориентированный граф. 
  
  Для каждого ребра задаётся его стоимость.

  Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью.
  
  Найденное ребро и соединяемые им две вершины образуют дерево. 
  
  Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. 
  
  Выбираемое на каждом шаге ребро присоединяется к дереву. 
  
  Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

  Результатом работы алгоритма является остовное дерево минимальной стоимости.


  Алгоритм: 
    1) Создать minHeap размера V, где V - количество вершин в данном графе. 
      Каждый узел minHeap содержит номер вершины и ключевое значение вершины. 
      
    2) Инициализируйте minHeap с первой вершиной в качестве корня (значение ключа, назначенное первой вершине, равно 0). 
      Значение ключа, присвоенное всем остальным вершинам, равно INF (бесконечно).

    3) Пока minHeap не пусто 
      a) Извлечь узел минимального значения из minHeap. Пусть извлеченная вершина будет u.
      
      b) Для каждой смежной вершины v из u проверьте, находится ли v в minHeap (еще не включено в MST). 
        Если v находится в minHeap и его значение ключа больше, чем вес u-v, то обновите значение ключа v как вес u-v.


  Итого: 
    Как результат мы получаем сумму минимального остовного дерева взвешенного связного неориентированного графа.


    
  Example: https://leetcode.com/problems/connecting-cities-with-minimum-cost/

*/

// Time O(V^2) or O((V + E) * LogV) same as for Dijkstra's
const primMST = (N, prims) => {
  let ans = 0;
  let map = new Map();
  let visited = new Set();
  let pq = new PriorityQueue({ comparator: (a, b) => a[1] - b[1] });

  for (let i = 1; i <= N; i++) {
    map.set(i, new Set());
  }

  for (let i = 0; i < prims.length; i++) {
    let [u, v, weight] = prims[i];

    map.get(u).add([v, weight]);
    map.get(v).add([u, weight]);
  }

  pq.offer([1, 0]);

  while (!pq.isEmpty()) {
    let [u, weight] = pq.poll();

    if (visited.has(u)) continue;

    visited.add(u);
    ans += weight;

    for (let [v, c] of map.get(u).values()) {
      pq.offer([v, c]);
    }
  }

  return visited.size == N ? ans : -1;
};
