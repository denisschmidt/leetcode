/*

  Алгори́тм Де́йкстры — алгоритм на графах находит кратчайшие пути от одной из вершин графа до всех остальных. 
  
  Алгоритм работает только для графов без рёбер отрицательного веса. 

  Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a.

  Алгоритм:

  Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки.

  Работа алгоритма завершается, когда все вершины посещены.

  1) Инициализация. Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности.
    Это отражает то, что расстояния от a до других вершин пока неизвестны.

  2) Все вершины графа помечаются как непосещённые.

  3) Если все вершины посещены, алгоритм завершается.

  4) В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.

    Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути.
    Равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.

  5) Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. 
    
  6) Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

   Итого: 
    Как результат получаем максимальную дистанцию в графе

*/

// Time O(ElogE)
// Space O(N + E)
const findMaxPath = (prims, N, K) => {
  let pq = new PriorityQueue({ comparator: (a, b) => a[1] - b[1] });
  let distance = new Map();
  let map = new Map();

  for (let [u, v, weight] of prims) {
    if (!map.has(u)) {
      map.set(u, []);
    }
    map.get(u).push([v, weight]);
  }

  pq.offer([K, 0]);

  while (!pq.isEmpty()) {
    let [u, weight] = pq.poll();

    if (distance.has(u)) continue;

    distance.set(u, weight);

    if (map.has(u)) {
      for (let [v, w] of map.get(u)) {
        if (distance.has(v)) continue;
        pq.offer([v, w + weight]);
      }
    }
  }

  if (distance.size != N) {
    return -1;
  }

  let max = 0;
  for (let dist of distance.values()) {
    if (dist == Number.MAX_VALUE) {
      return -1;
    }
    max = Math.max(max, dist);
  }

  return max;
};
