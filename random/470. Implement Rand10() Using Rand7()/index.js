/*
Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.

Do NOT use system's Math.random().

 

Example 1:

Input: 1
Output: [7]
Example 2:

Input: 2
Output: [8,4]
Example 3:

Input: 3
Output: [8,1,10]
 

Note:

rand7 is predefined.
Each testcase has one argument: n, the number of times that rand10 is called.
 

Follow up:

What is the expected value for the number of calls to rand7() function?
Could you minimize the number of calls to rand7()?

 */

/*
Анализ проблемы

Это решение основано на Rejection Sampling.

Основная идея заключается в том, что когда вы генерируете число в нужном диапазоне, выведите это число немедленно.
Если число выходит за пределы желаемого диапазона, отклоните его и повторите выборку.
Поскольку каждое число в желаемом диапазоне имеет одинаковую вероятность выбора, создается равномерное распределение.

Очевидно, что нам нужно запустить функцию rand7() как минимум дважды, так как не хватает чисел в диапазоне от 1 до 10.
Запустив rand7 () дважды, мы можем получить целые числа от 1 до 49 равномерно.

Почему именно дважды ?
Представьте, что rand7() имеет 7-гранный кубик.

Так как нам нужен rand10() (10-сторонний кубик) и 10 больше 7, нам нужно несколько раз бросить 7-сторонний кубик.

Двойной бросок 7-гранного кубика дает 49 различных комбинаций

(1,1)
(1,2)
(1,3)

...
(7,7)

Теперь нам нужно как-то различать эти 49 разных результатов.
Как мы можем сопоставить два наших 7-сторонних броска кубика с этими различными числами результатов (1-49)?

Первое, что приходит на ум, - это умножить два числа в каждом кортеже.
Но это приводит к неравномерному распределению, потому что вы получите (1,1) = 1 (1,2) = 2 (2,1) = 2


Видите, как результат «2» может появиться дважды, в то время как результат «1» может появиться один раз? Это потому, что умножение не заботится о порядке.


Один из способов решения этой проблемы - думать о каждом броске костей как о строке / столбце матрицы 7x7.


  1  2  3  4  5  6  7
1
2
3
4
5
6
7


Таким образом, положение (1,1) соответствует результату 1. 
Положение (1,2) отображается на результат 2. ... 

Положение (1,7) отображается на результат 7. 

Положение (2,1) отображается на результат 8. 

Как мы можем получить это число, используя математику для данной (x, y) позиции? 

7 (х-1) + у Так почему же итоговая формула будет такой ===> 7 (x-1) + (y-1)?

Потому что это делает % 10 проще.

Вместо того, чтобы сделать результат пространства 1-49.

Мы делаем его 0-48. Вы можете оставить это как 1-49, но как видите: 1 11 21 31 10 20 30 40 Ваш код должен выглядеть следующим образом:
return result%10 === 0 ? 10 : result%10;


*/

/**
 * The rand7() API is already defined for you.
 * const rand7 = function() {}
 * @return {number} a random integer in the range 1 to 7
 */

// В среднем для этого алгоритмаа необходимо 49/40*2 = 2.45 бросков для равномерного распределения
// Time O(1)
// Time O(Infinity) worst case
const rand10 = () => {
  while (true) {
    let num = 7 * (rand7() - 1) + (rand7() - 1);

    if (num < 40) {
      return (num % 10) + 1;
    }
  }
};
