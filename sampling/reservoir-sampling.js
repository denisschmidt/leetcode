/*

Reservoir Sampling

Алгоритм Reservoir Sampling

Можно использовать, когда вы хотите вывести n элементов из диапазона [0, N).

Если N не слишком велико, скажем, 10 000 или меньше, тогда простой подход - создать массив со значениями [0, N),
перемешать значения (используя алгоритм Фишера-Йейтса), а затем вернуть первые n значений в массив.

Но если N заранее неизвестно, отбор через алгоритм Reservoir Sampling полезен

Учитывая большой массив (или поток) чисел (для упрощения), и нам нужно написать эффективный * функция случайного выбора k чисел,
где 1 <= k <= n.

Пусть входной массив будет stream[].

Как это работает?

Чтобы доказать, что это решение работает идеально, мы должны доказать, что вероятность того, что любой элемент
из потока stream[i], где 0 <= i < n будет в конечном резервуаре[], равен k / n.

Давайте разделим доказательство на два случая, когда первые k элементов обрабатываются по-разному.


Случай 1: для последних n-k элементов потока, то есть для потока stream[i], где k <= i < n
Для каждого такого потока элементов stream[i] мы выбираем случайный индекс от 0 до i,
и если выбранный индекс является одним из первых k индексов, мы заменяем элемент в выбранном индексе на stream[i]


Чтобы упростить доказательство, давайте сначала рассмотрим последний элемент. Вероятность того, что последний элемент
в конечном резервуаре = вероятность того, что один из первых k индексов выбран для последнего элемента = k / n
(вероятность выбора одного из k элементов из списка размера n)


Давайте теперь рассмотрим второй последний элемент. Вероятность того, что второй последний элемент находится в конце reservoir[] равно

[Вероятность того, что один из первых k индексов будет выбран в итерации для stream[n-2]]
X
[Вероятность того, что индекс, выбранный в итерации для потока [n-1], не совпадает с индексом выбрано для потока [n-2]] = [k / (n-1)] * [(n-1) / n] = k / n.

Точно так же мы можем рассмотреть другие элементы для всех элементов потока от stream[n-1] до stream[k] и обобщить доказательство.


Случай 2: Для первых k элементов потока, то есть для stream[i], где 0 <= i <k
Первые k элементов первоначально копируются в reservoir[] и могут быть удалены позже в итерациях для stream[k] в stream[n].

Вероятность того, что элемент из потока [0..k-1] находится в окончательном массиве = Вероятность того, что элемент не выбран, когда элементы
stream [k], stream [k + 1], ... stream [n-1] считаются = [k / (k + 1)] x [(k + 1) / (k + 2)] x [ (k + 2) / (k + 3)] x… x [(n-1) / n] = k / n

Когда k + i достигает n, вероятность каждого числа, остаться в резервуаре, равна k / n.

 */

const randomInt = (min, max, inclusive = false) => Math.floor(Math.random() * (max - min + inclusive ? 1 : 0)) + min;

const selectKItems = (stream, k) => {
  const n = stream.length;

  const reservoir = Array(k);

  // reservoir[] - выходной массив. Инициализируйте его первыми k элементами из stream[]
  for (let i = 0; i < k; i++) {
    reservoir[i] = stream[i];
  }

  //итерация от (k + 1) -го элемента до n-го элемента
  for (let i = k + 1; i < n; i++) {
    // выбираем случайный элемент 0 to i
    const j = randomInt(0, i, true);

    // Если случайно выбранный индекс меньше k заменить элемент, присутствующий в индексе
    // с новым элементом из потока
    if (j < k) {
      reservoir[j] = stream[i];
    }
  }
};
