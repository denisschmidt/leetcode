/*

В полном двоичном дереве каждый уровень, за исключением, возможно, последнего, полностью заполнен,
и все узлы на последнем уровне расположены как можно левее.

Это означает, что полное дерево имеет 2^K узлов на k-м уровне, если k-й уровень не последний.

Последний уровень может быть заполнен не полностью, и,
следовательно, на последнем уровне количество узлов может варьироваться от 1 до 2^d где d - глубина дерева.


Теперь можно вычислить количество узлов на всех уровнях, кроме последнего. 2^d - 1 где d - глубина дерева.

Это сводит проблему к простой проверке количества узлов дерева на последнем уровне.


Алгоритм

  1) Вернуть 0, если дерево пусто.

  2) Вычислить глубину дерева d.

  3) Вернуть 1, если d == 0.

  3) Количество узлов на всех уровнях, кроме последнего, 2^d - 1 где d - глубина дерева.
   Количество узлов на последнем уровне может варьироваться от 1 до 2^d.
   Перечислить потенциальные узлы от 0 до 2^d - 1 и выполните двоичный поиск по индексу узла, чтобы проверить,
   сколько узлов находится на последнем уровне.

   Использовать функцию бинарного поиска isExist(idx, d, root), чтобы проверить, существует ли узел с индексом idx.

  4) Вернуть 2^d - 1 + число узлов на последнем уровне
 */

const computeDepth = node => {
  let count = 0;

  while (node.left !== null) {
    node = node.left;
    count++;
  }

  return count;
};

const isExist = (idx, depth, node) => {
  let left = 0;
  let right = Math.pow(2, depth) - 1;
  let pivot;

  for (let i = 0; i < depth; i++) {
    pivot = Math.floor(left + (right - left) / 2);

    if (idx <= pivot) {
      node = node.left;
      right = pivot;
    } else {
      node = node.right;
      left = pivot + 1;
    }
  }

  return node !== null;
};

// Time O(d^2) = O(log^2 * N) где d - глубина дерева
// Space O(1)
const countNodes = function (root) {
  // если дерево пустое
  if (root === null) return 0;

  // получает глубину
  let depth = computeDepth(root);

  // если дерево содержит 1 ноду
  if (depth === 0) return 1;

  // Узлы последнего уровня нумеруются от 0 до 2^ d - 1
  // Выполнить бинарный поиск, чтобы проверить, сколько существует узлов.

  let left = 1;
  let right = Math.pow(2, depth) - 1;
  let pivot;

  while (left <= right) {
    pivot = Math.floor(left + (right - left) / 2);
    if (isExist(pivot, depth, root)) {
      left = pivot + 1;
    } else {
      right = pivot - 1;
    }
  }

  return Math.pow(2, depth) - 1 + left;
};
