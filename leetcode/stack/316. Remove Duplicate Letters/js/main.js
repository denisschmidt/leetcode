/*

Много проблем может быть решено с помощью dp.

Решить, используя жадную стратегию, труднее, поскольку вам нужно доказать, что жадность будет работать для этой проблемы.

Есть некоторые явные признаки проблемы, где жадность может быть применима, но не сразу очевидна.

Пример:
  1) Выбор элемента зависит только от его непосредственных соседей (wiggle sort).
  2) Ответ монотонно не убывает или не увеличивается (сортировка). Это также применимо для LIS.
  3) Все, что требует лексикографически наибольшего или наименьшего чего-либо.
  4) Все, что требует ввод в отсортированном порядке, поможет.
  5) Все, что требует ввод в прямом или обратном направлении
  6) Все, что требует от вас отслеживания минимума или максимума чего-либо (подумайте о проблемах со скользящим окном).

Все это свидетельствует о том, что жадная стратегия может быть применима.

*/

// Time O(N)
// Space O(N)
const removeDuplicateLetters = s => {
  let st = [];
  let lastIndex = new Map();
  let visited = new Set();

  for (let i = 0; i < s.length; i++) {
    lastIndex.set(s[i], i);
  }

  for (let i = 0; i < s.length; i++) {
    if (visited.has(s[i])) continue;

    // нужно ли нам удалять символ из стека или нет
    while (st.length && st[st.length - 1] > s[i] && lastIndex.get(st[st.length - 1]) > i) {
      let x = st.pop();
      visited.delete(x);
    }

    st.push(s[i]);
    visited.add(s[i]);
  }

  return st.join('');
};
