/*
  Корень MHT(мин высоты дерева) должен быть средней точкой (или двумя средними точками) самого длинного пути дерева.

  Хотя в самом корне дерева могут появляться несколько самых длинных путей, они должны иметь одну и ту же среднюю точку.

  Наша задача - найти минимальную высоту деревьев и вернуть их корневые метки. 
  
  Сначала мы можем подумать о простом случае - графе путей. 
  
  Для графа путей из n узлов найти деревья минимальной высоты тривиально. 
  
  Просто обозначьте среднюю точку (точки) как корни. 
  
  Несмотря на свою тривиальность, давайте разработаем алгоритм их поиска. 
  
  Предположим, что мы не знаем n и не имеем произвольного доступа к узлам. 
  
  Решение с двумя указателями. По одному с каждого конца и начинаем двигаться с одинаковой скоростью. 
  
  Когда они встречаются или находятся на расстоянии одного шага (зависит от четности n), у нас есть нужные нам корни. 
  
  Это дает нам много полезных идей для решения нашей настоящей проблемы. 
  
  Для дерева мы можем сделать нечто подобное. 
  
  Мы начинаем со всех концов, под концом мы подразумеваем вершину степени 1 (иначе листья). 
  
  Мы позволяем указателям двигаться с одинаковой скоростью. 
  
  Когда встречаются два указателя, мы оставляем только один из них, пока два последних указателя не встретятся или не отойдут на шаг, и мы не найдем корни. 
 
  Последние два указателя находятся с двух концов самого длинного пути в графе. 
  
  Реальная реализация аналогична топологической сортировке BFS. 
  
  Основная идея заключается в том, чтобы «Продолжать удалять листья слой за слоем, пока не достигним корня».

  Сначала находим все листья, затем удаляем их. После удаления некоторые узлы станут новыми листьями. 
  
  Таким образом, мы можем продолжать удалять их. 
  
  В конце концов, остается только 1 или 2 узла. 
  
  Если остался только один узел, это корень. 
  
  Если есть 2 узла, любой из них может быть возможным корнем.

*/

// Time O(N)
// Space O(N)
const findMinHeightTrees = (n, edges) => {
  if (edges.length === 0) return [0];

  // Строим граф исходя из заданных вершин
  let graph = buildGraph(n, edges);

  // Записываем все листья в массив
  let leaves = [];
  for (let i = 0; i < n; i++) {
    if (graph.get(i).size === 1) {
      leaves.push(i);
    }
  }

  // Делаем BFS обход. Удаляем все листья, пока не останется только два листа
  while (n > 2) {
    let size = leaves.length;

    n -= size;

    for (let i = 0; i < size; i++) {
      let u = leaves.shift();

      graph.get(u).forEach(v => {
        graph.get(v).delete(u);

        if (graph.get(v).size === 1) {
          leaves.push(v);
        }
      });
    }
  }

  return leaves;
};

function buildGraph(n, edges) {
  let graph = new Map();

  for (let i = 0; i < n; i++) {
    graph.set(i, new Set());
  }

  edges.forEach(([u, v]) => {
    graph.get(u).add(v);
    graph.get(v).add(u);
  });

  return graph;
}
